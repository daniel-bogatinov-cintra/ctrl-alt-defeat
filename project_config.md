Prompt for vibecoding (copy-paste this whole thing)

You are building a small web app called Meme Retro for a three-person team (and future teammates) to run meme-based retrospectives. The goal is to quickly generate, collect, and react to memes that describe how the sprint felt, instead of writing long, boring bullet points. The app should be simple, fast, and optimized for short sessions where people just drop memes, react, and then export the results. Use a modern web stack with a TypeScript React frontend and a lightweight backend (Node/TypeScript or Next.js API routes). Prioritize developer ergonomics and clarity in the implementation.

Step 1 ‚Äì Set up the project structure. Create a web app with: a frontend (React + TypeScript; Next.js with the App Router is preferred) and a backend layer for APIs. Use Tailwind CSS for styling and a minimal, clean UI with a slightly playful aesthetic (rounded corners, soft shadows, nice spacing). Organize the code into clear modules: modules/retro, modules/memes, and modules/integrations (for future Slack/etc.). Provide an .env.example file where configuration is declared, including MEMEGEN_BASE_URL (defaulting to https://api.memegen.link) and DATABASE_URL (for Postgres or SQLite).

Step 2 ‚Äì Design the domain models and persistence. Implement a simple database schema using something like Prisma, or any ORM in TypeScript. Define at least these entities: Retro (id, title, teamName, createdAt, status [draft/active/closed]); Participant (id, retroId, displayName, optional avatarColor); MemeTemplate (id, memegenId, displayName, previewUrl, lines, createdAt); and MemeEntry (id, retroId, participantId, templateId, topText, bottomText (or generic lines array), generatedImageUrl, createdAt, optional tags and reactions as JSON). Ensure foreign keys are respected and include basic indexes on retroId for fast queries.

Step 3 ‚Äì Implement a backend service that wraps the memegen API. Use the public API at https://api.memegen.link, but make the base URL configurable via MEMEGEN_BASE_URL. Implement a MemegenClient class or module with methods like: listTemplates() (GET /templates/ to fetch and cache available templates), buildMemeUrl(templateId, lines, options) (constructs the /images/{templateId}/{line1}/{line2}.png URL with proper escaping, plus optional width, height, layout, font query params), and optionally validateTemplate(templateId) (check against the cached template list). Handle character escaping according to memegen rules (underscores/dashes mapping to spaces, tilde sequences like ~q for ?, ~s for /, etc.) so the user can type normal text and your code does the conversion before building the URL.

Step 4 ‚Äì Create API endpoints for the app. Implement at least these JSON APIs: GET /api/retros (list retros), POST /api/retros (create a retro with title and teamName), GET /api/retros/:id (fetch retro details, participants, and memes), POST /api/retros/:id/participants (join a retro with a displayName), GET /api/templates (return a curated subset of memegen templates from the database or directly from the memegen API), and POST /api/retros/:id/memes (create a meme within a retro). The meme-creation endpoint should accept templateId, lines (array of strings), and participantId. It should use the MemegenClient to construct the final meme image URL, then store a MemeEntry with that URL and return it to the frontend.

Step 5 ‚Äì Build the main UI flow for retros. Create a landing page that lists existing retros in a simple card layout with title, team name, and createdAt. Allow users to create a new retro via a modal or dedicated page with fields for retro title and optional team name. When a retro is created or selected, navigate to a /retro/[id] page that contains the full meme retro experience. On the retro page, the user should first pick or type a display name (e.g. ‚ÄúPeter‚Äù, ‚ÄúDaniel‚Äù, ‚ÄúMatt‚Äù or something more chaotic), and that is stored in local state and persisted via the participants API so we have a participantId for future meme submissions.

Step 6 ‚Äì Implement the meme creation interface. On the retro page, add a sidebar or panel to create a new meme: a template dropdown (or grid of preview images) populated from /api/templates, text input fields for each line the template expects (top/bottom, or multiple lines for templates that support more), and options such as font and layout if you want to expose them simply. As the user types, construct the memegen URL on the client side using the same escaping rules, and show a live preview via an <img> element pointing to the memegen-generated URL. When the user clicks ‚ÄúPost meme to retro‚Äù, send the data to POST /api/retros/:id/memes to persist it and then refresh the meme list.

Step 7 ‚Äì Display memes in a collaborative feed. Below or next to the creation form, render a meme feed for the retro: each MemeEntry should show the generated image, the participant display name, created time (e.g. ‚Äú2 mins ago‚Äù), and optional tags. Layout should be responsive: in a retro with few memes, they can appear in a column; in larger sets, a masonry or grid layout works. Implement basic filters/sorts (e.g. sort by newest, by most reactions, or by participant). Add a subtle ‚Äúempty state‚Äù that invites people to create the first meme with some playful copy like ‚ÄúThis retro has 0 memes. So basically it hasn‚Äôt even started.‚Äù

Step 8 ‚Äì Add reactions and light interaction. For each meme, provide quick one-click reactions such as üòÇ, üî•, üíÄ, and ‚úÖ. Store reactions in a separate table or as aggregated counts on MemeEntry (e.g. reactions JSON field mapping emoji to count and maybe a list of participantIds). Implement a small API endpoint POST /api/memes/:id/reactions to add or toggle a reaction. On the frontend, update the counts optimistically for a snappy feel. You do not need fully real-time websockets, but if it‚Äôs easy in the chosen stack, you can implement periodic polling or lightweight server-sent updates to keep multiple viewers in sync during a retro.

Step 9 ‚Äì Implement export and sharing. Add an ‚ÄúExport Retro‚Äù button on the retro page that allows the team to: (a) download a simple HTML or Markdown report containing all meme image URLs plus their captions and reaction counts, and (b) generate a printable view that shows all memes on one page, suitable for saving as PDF via the browser. You can also provide a ‚ÄúCopy link to meme‚Äù action per meme so users can drop individual memes into Slack or other tools. The exported views should be read-only and should not require authentication beyond having the retro‚Äôs share link.

Step 10 ‚Äì Handle configuration, error states, and the memegen dependency gracefully. Read MEMEGEN_BASE_URL from environment variables, defaulting to https://api.memegen.link. If the memegen API is down or unreachable, show a clear error in the meme creation UI (e.g. ‚ÄúMeme engine is having an existential crisis. Try again later.‚Äù) and return appropriate HTTP error codes from the backend. Add minimal logging for failed calls to the memegen API, including URL and response status. Also, implement a small in-memory or short-lived cache for the templates list and possibly for frequently used meme URLs, to avoid hammering the memegen service unnecessarily.

Step 11 ‚Äì Keep the implementation ready for self-hosting the memegen backend. Assume that in the future, the team might deploy the jacebrowning/memegen repo themselves. That means your MemegenClient must treat MEMEGEN_BASE_URL as a fully configurable host, and it should not hardcode api.memegen.link anywhere except as the default. Don‚Äôt rely on undocumented behavior: use the documented URL structure like /images/{templateId}/{top}/{bottom}.png and /templates/. Keep timeouts and error handling generic so they work whether the memegen instance is public or self-hosted.

Step 12 ‚Äì Focus on clean code, typing, and DX. Use TypeScript end-to-end with proper types for Retro, MemeTemplate, MemeEntry, Participant, and the responses from the memegen API (at least the fields you actually use, like id, name, lines, blank, example, etc.). Split the UI into small, reusable components: RetroList, RetroPage, ParticipantNameDialog, MemeCreator, MemeFeed, MemeCard, ReactionBar. Apply Tailwind classes in a consistent design system (e.g. base background, card surface, accent color for buttons). Include basic form validation and loading states so the app doesn‚Äôt feel half-baked. End with a brief README section in the code comments that explains how to run the app, how to configure MEMEGEN_BASE_URL, and how to start a retro from scratch.

Quick viability check on memegen for this use case
    ‚Ä¢ The GitHub repo jacebrowning/memegen is MIT licensed, which is permissive and fine for use in an internal tool or even commercial stuff, as long as you follow the license terms. (GitHub)
    ‚Ä¢ The live service at api.memegen.link is ‚ÄúThe free and open source API to generate memes‚Äù and works fully via URLs (stateless, no auth): /images/{template}/{top}/{bottom}.{ext} gives you a meme; there‚Äôs a /templates/ endpoint listing all templates with metadata. (GitHub)
    ‚Ä¢ It supports multiple formats (.png, .jpg, .gif, .webp), custom dimensions (width/height query params), different layouts (layout=top), multiple fonts, emojis, and escaping for special characters, which is exactly what you want for silly-but-flexible retro memes. (GitHub)
    ‚Ä¢ For reliability, you have two options:
        ‚óã Use the hosted api.memegen.link as a free external dependency (good enough for internal tooling; there‚Äôs even a ‚Äúbuy me a coffee‚Äù link, so it‚Äôs clearly a maintained public service). (GitHub)
        ‚óã Or self-host the repo using its Containerfile/Procfile setup if you get paranoid or your team starts spamming memes at unsafe volumes. (GitHub)
        
So yes, your ‚Äúmeme retro‚Äù thing is totally viable with this repo as the meme engine. You bring the psychology and the sprint pain; it brings the JPEGs and the questionable life choices.

Extra Requirements: Real-Time Updates & Shareable Retro Links
Extend the implementation with real-time collaboration for each retro, and shareable retro IDs so participants can join easily.
When a Retro is created, generate both:
    ‚Ä¢ A stable internal id (UUID or numeric)
    ‚Ä¢ A user-facing unique shareId or slug (e.g. short UUID, nanoid, or hash)
Store both in the Retro model as id and shareId. The app‚Äôs URLs for participants should use shareId, e.g. /retro/[shareId]. All backend lookups that originate from the user-facing URL should resolve shareId to the internal id. This allows safe sharing of the retro link without exposing database IDs.
Update the APIs so that:
    ‚Ä¢ POST /api/retros returns both id and shareId, plus the full participant link as a convenience (e.g. joinUrl).
    ‚Ä¢ GET /api/retros/:shareId resolves via shareId instead of numeric id.
    ‚Ä¢ All meme/participant operations are scoped by the retro‚Äôs internal id but accept shareId in the URL and translate internally.
Implement a real-time updates layer so that when one participant creates a meme, adds a reaction, or joins the retro, other participants who are on the same retro page see updates without manual refresh. You can use WebSockets, Server-Sent Events (SSE), or any similar mechanism supported by the chosen stack. Prefer a simple WebSocket implementation using a single channel per retro, for example: a room named retro:{retroId} that all connected clients for that retro subscribe to.
Create a small abstraction in the backend, e.g. RetroEvents or RealtimeHub, with methods like: broadcastMemeCreated(retroId, memeEntry), broadcastReactionUpdated(retroId, reactionPayload), and broadcastParticipantJoined(retroId, participant). Whenever the normal REST API handlers successfully create a meme, add a reaction, or create a participant, they should call these broadcast methods so the event is pushed over the WebSocket/SSE channel to other connected clients.
On the frontend, in the RetroPage component, open a real-time connection when the page mounts and the retro is loaded. Subscribe to the retro channel (e.g. retro:{retroId}), and handle messages such as meme_created, reaction_updated, and participant_joined. Update the local React state for memes, reactions, and participant lists in response to those messages. Ensure that the client that triggered the event can rely on local optimistic updates, but still reconciles with the real-time event payload in case the backend enriches data (e.g. timestamps, IDs).
Handle connection lifecycle gracefully: show a subtle indicator if the real-time connection drops (e.g. ‚ÄúLive updates paused, reconnecting‚Ä¶‚Äù), and retry with exponential backoff or reasonable intervals. The app must continue functioning with plain REST calls even if the WebSocket/SSE connection is down, but the UX will be degraded to manual refresh or periodic polling. Don‚Äôt break the core retro functionality if real-time fails.
On the UI side, make the shareable link obvious: after creating a retro, display the link (e.g. https://your-app/retro/{shareId}) with a ‚ÄúCopy link‚Äù button. Also show the link or a small ‚ÄúInvite others‚Äù control on the retro page itself, so the facilitator can grab it any time. You can also show a simple participants bar (‚Äú3 people in this retro‚Äù) powered by the same real-time presence data, updated whenever someone joins or leaves (if you implement presence; otherwise just update on participant_joined events).
Security-wise, for this initial version, you can treat possession of the shareId as enough to join the retro (a ‚Äúsecret link‚Äù model). Assume this is an internal team tool, not a public internet free-for-all. Structure the code so that later, if needed, additional auth (e.g. workspace login) can be added on top without rewriting everything: keep retro access checks in a single place in the backend.
Finally, document in comments or a short README section how the real-time layer works: what transport is used (WebSockets or SSE), how events are named (e.g. meme_created, reaction_updated, etc.), how clients subscribe, and how shareId maps to internal retro id. This will save future-you (and future-devs) from having to reverse-engineer your ‚Äúit totally made sense in my head at the time‚Äù decisions.

Extra Requirement: Retro Lanes (Column Layout with Memes)
Extend the UI so that each retro has lanes, similar to a classic retrospective board (columns like ‚ÄúWent well‚Äù, ‚ÄúTo improve‚Äù, etc.), and memes are placed into these lanes instead of just being in a single flat feed.
Add a Lane concept to the domain model. You can represent lanes either as a dedicated table/model (e.g. Lane with id, retroId, title, slug, order) or as a structured JSON field on the Retro if you want to keep it simpler. Prefer an explicit Lane model so lanes can be edited later. Each MemeEntry should reference a lane via laneId so that every meme belongs to exactly one lane.
When a new retro is created, automatically seed it with a default set of lanes in a fixed order. For example, use four initial lanes:
    ‚Ä¢ ‚ÄúWhat went well‚Äù
    ‚Ä¢ ‚ÄúWhat didn‚Äôt go well‚Äù
    ‚Ä¢ ‚ÄúIdeas / Experiments‚Äù
    ‚Ä¢ ‚ÄúKudos / Shoutouts‚Äù
Store these as Lane records tied to the retroId. In the future, allow customization, but for now it‚Äôs enough to seed these defaults and keep them stable per retro.
Update the API responses so that GET /api/retros/:shareId returns not just the retro data and memes, but also the list of lanes (with their IDs, titles, and order). The frontend should use this to render a multi-column board layout. Group memes by laneId on both backend and frontend: server-side for queries and frontend for display and state updates.
On the UI side, change the retro page from a simple feed into a column-based board. Render each lane as a vertical column with a clear heading (lane title) and a stack of MemeCards underneath. Use a responsive layout where lanes scroll vertically but stay in a row horizontally (e.g. using CSS grid or flexbox with overflow on the x-axis if needed). Make each lane visually distinct with subtle background and header styling, but keep the overall aesthetic consistent with the rest of the app.
When creating a meme, the user must choose which lane it belongs to. In the MemeCreator UI, add a required lane selector (e.g. a dropdown with the lane titles, or clickable lane pills). The selected lane‚Äôs laneId should be sent in POST /api/retros/:id/memes and stored on the corresponding MemeEntry. The newly created meme should immediately appear under that lane in the board.
Optionally, support drag-and-drop between lanes so participants can move memes as discussions evolve. Implement a simple drag-and-drop interaction: dragging a MemeCard from one lane to another triggers an update request (e.g. PATCH /api/memes/:id with the new laneId). The backend updates the record and broadcasts an event via the real-time system so all participants see the meme move lanes in near real time.
Integrate lanes with the real-time updates layer. When a meme is created, include its laneId in the meme_created event payload so other clients can insert it into the correct lane. When a meme is moved between lanes (if drag-and-drop is implemented), broadcast a meme_moved event with memeId, fromLaneId, and toLaneId. Clients should update their local lane-specific lists rather than refetching everything each time.
Allow simple lane-level controls to help facilitate the retro. For example, add a ‚Äúcollapse lane‚Äù toggle for each column, so the facilitator can focus on one lane at a time during discussion. Optionally, add a small counter in the lane header (e.g. ‚Äú7 memes‚Äù) and maybe a quick filter that highlights memes with certain reactions (like üî• or üíÄ) when the facilitator wants to focus on controversial items.
Ensure the export functionality respects lanes. When exporting a retro to Markdown/HTML or a printable view, group memes by lane in the output. Display the lane title as a section heading, followed by its memes (image, caption text, participant, and reaction summary). This makes the exported artifact look like a structured retro summary instead of a chaos scroll.
Finally, keep the UX simple: lanes are there to give structure, not to turn the retro into a project management tool. Avoid overcomplicating with per-lane permissions or complex settings at this stage. A straightforward ‚Äúcolumns with memes inside them‚Äù design is sufficient, as long as creation, movement, and real-time updates all understand Lane as a first-class concept.
